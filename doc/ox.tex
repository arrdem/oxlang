\documentclass{report}

% Packages
\usepackage[T1]{fontenc}
\usepackage[usenames,dvipsnames]{color}
\usepackage[utf8]{inputenc}
\usepackage{courier}
\usepackage{extramarks}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{lastpage}
\usepackage{lipsum}
\usepackage{listings}
\usepackage{textcomp}

% Margins
\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1} % Line spacing

% Set up the header and footer
\pagestyle{fancy}
\lhead{} % Top left header
\chead{} % Top center head
\rhead{} % Top right header
\lfoot{} % Bottom left footer
\cfoot{} % Bottom center footer
\rfoot{Page\ \thepage\ of\ \protect\pageref{LastPage}} % Bottom right footer
\renewcommand\headrulewidth{0.4pt} % Size of the header rule
\renewcommand\footrulewidth{0.4pt} % Size of the footer rule

\setlength\parindent{0pt} % Removes all indentation from paragraphs

\lstloadlanguages{Lisp}
\lstset{language=Lisp,
  frame=single,
  basicstyle=\small\ttfamily,
  keywordstyle=[1]\color{Blue}\bf,
  keywordstyle=[2]\color{Purple},
  keywordstyle=[3]\color{Blue}\underbar,
  identifierstyle=\color{MidnightBlue},
  commentstyle=,
  stringstyle=\color{Purple},
  showstringspaces=false,
  tabsize=5,
  morekeywords={rand},
  morekeywords=[2]{on, off, interp},
  morekeywords=[3]{test},
  morecomment=[l][\color{Blue}]{...},
  numbers=left,
  firstnumber=1,
  numberstyle=\tiny\color{Blue},
  stepnumber=1
}

%----------------------------------------------------------------------------------------
%       NAME AND CLASS SUBSECTION
%----------------------------------------------------------------------------------------

\def\rnrs{RNROx }
\newcommand{\Title}{Ox, the Language}
\newcommand{\AuthorName}{Reid 'arrdem' McKenzie <me@arrdem.com>}

%----------------------------------------------------------------------------------------
%       TITLE PAGE
%----------------------------------------------------------------------------------------

\title{
  \vspace{2in}
  \textmd{\textbf{\Title}}\\
  \vspace{0.1in}\large{\textit{$-1^{st}$ ed.}}
  \vspace{3in}
}

\author{\textbf{\AuthorName}}
\date{}

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle

%----------------------------------------------------------------------------------------
%       TABLE OF CONTENTS
%----------------------------------------------------------------------------------------

\newpage
\tableofcontents
\newpage

\chapter{Motivation}

This chapter is a candidate for later deletion but for now I find it expedient
to keep it around.

Ox is born first and foremost of Rich Hickey's language Clojure. After spending
a summer hacking on Oxcart, an optimizing Clojure compiler intended to be my
undergraduate thesis material, I came to the conclusion that the compiler I
produced targeted a sufficiently restricted subset of Clojure that it was a
different beast altogether and that since I had already jumped the shark and
built my own Lisp I may as well go whole hog and deal with some bugbears of mine
in Clojure while I was at it.

The result is Ox. Ox is a Lisp at least in name, which seeks to steal the best
of Clojure's imperative but mostly side effect free word and Haskell's types and
category theory, then mix it together with a lispy notation. The hope is that in
so doing, the rewards of static typing and static reasoning (more advanced
optimization and proofs about properties of programs) can be made achievable in
a near Clojure language on the JVM platform while learning from Clojure's
evolutionary history and leaving the door open to other platforms in the form of
a Shen like portable testable language specification.

The goal of this document is to present, in a structured, printable, coherent
form the design philosophy of the Ox language, the philosophy under which it
will be developed, the language itself and some thoughts with respect to its
use.

\chapter{The Reader and Notation}


Ox, being a Lisp family language, uses an expression based syntax which seeks to
share as much notation as possible between logical evaluated code and data so
that the $eval$ relation from data to code is as transparent as possible. An
expression in Ox is one of the following


\section{Whitespace}


As in traditional Lisps, the \verb|;| character is the comment prefix. All
characters between a \verb|;| and the end of line are ignored and invisible to
the logical structure of the program. Readers may choose to read comments as
strings and attach them as metadata to forms.

The space, tab, newline, page break, linefeed and comma characters are all white
space and ignored in between individual forms. That is to say a single list as
subsequently defined may span arbitrarily much whitespace and arbitrarily many
lines. That is not to say that individual terms such as symbols can span lines
and whitespace unless they are specifically noted to do so or contain subforms
between which whitespace is always valid.

\section{Lists}


Written as a sequence of terms delimited by ( ... ), Lists are used as the basic
syntactic element.

\section{Numbers}


Integers (\verb|0x|, \verb|0b|, \verb|0o|, implicit base 10), Longs, Bignums,
Floats, Ratios.

\section{Characters}


Characters are reader notation for the byte string representing a textual
glyph. Characters begin with the \verb|\| character,\ç‰›

\section{Symbols}


A sequence of characters forming a symbolic name in a program. Symbols may
either be qualified or unqalified.

\subsection{Unqualified symbols}
An unqualified symbol is textually a sequence of non-whitespace, non-delimiter
characters terminated by but not including either whitespace or a delimiter for
some other expression. The set of strings (character sequences) which constitute
valid symbols is referred to as \verb|Names|, and are defined by the pattern
\begin{verbatim}
(/+)|([^\^\[\]\(\)\{\}#:"';\\s\d,\\][^\^\[\]\(\)\{\}#:"';\\s,\\]+)
\end{verbatim}

Examples of valid symbols include: \verb|a|, \verb|foo|, \verb|FooBarBazQux|,
\verb|a.b.c| \verb|org.foo.bar.MyType.|, \verb|%|, \verb|/|, \verb|//|,
\verb|/////|, \verb|->|, \verb|**|, \verb|foo_gen_1234| and any other string
which does not constitute either multiple symbols or forms.

Note that the strings \verb|/foo|, \verb|'foo|, \verb|foo[]bar|, \verb|foo^bar|,
\verb|bar(qux)baz|, \verb|12a34| and soforth are not valid symbols and in fact
are all multiple forms.

\subsection{Qualified symbols}
An qualified symbol is logically of a tuple \verb|<namespace, name>| written
textually as \verb|namespace/name|. This is said to be a qualified symbol, in
that the namespace uniquely identifies the packaging context of a given symbol
and then uniquely names the symbol within that context.

While a \verb|Name| as listed above may contain the character \verb|/|, the
\verb|Namespace| production is defined to exclude that character thus ensuring
that the tokenization of a qualified symbol is unique compared to the
tokenization of an unqualified symbol.

Examples of valid symbols include: \verb|ox.math/+|,
\verb|grimoire.api/list-defs|, \verb|clojure.core/concat|, \verb|foo/->>|,
\verb|ox.core//|, \verb|ox.core/////| and soforth.

\section{Keywords}


Keywords are Symbols (either qualified or unqualified) prefixed with the pattern
\verb|::?| which are used textually to represent symbolic constants especially
the names of map keys or set/enumeration entries.

The \verb|:| prefix on a Keyword denotes that a keyword is fully present
textually. The \verb|::| prefix on a Keyword denotes that the Namespace part of
the Keyword is the aliased name of a namespace in the current namespace and
should be replaced with the full name of that namespace.

Examples of valid Keywords include \verb|:foo|, \verb|:foo/bar|, \verb|::a/b|,
\verb|:a/b3|, \verb|:clojure.core/->>| and soforth.

\section{Strings}


Strings are a block of arbitrary text contained within double or tripple quotes.

TODO: What do we want/need tripple quoted strings for?

Double quoted strings are for character strings as program data and constants.

Tripple quoted strings are for documentation, are expected to be fully
indented to the indentation level of the containing block and contains text
formatted in accordance to the Common Markdown specification.

\begin{lstlisting}
  (def foo
     """
     # The Foo Function
   
     This is some documentation that totally starts with a Markdown header and
     may contain Markdown code blocks, underlines, italics and soforth.
     """
   
     (fn [x] ...))
\end{lstlisting}

Being data, strings evaluate to themselves. Strings contain no subterms.

\section{Vectors}


A sequence of terms delimited by [ ... ]

Where lists are notation for code and function invocation, vectors are
notation for ordered binding terms.

In a traditional Lisp (say an ) or Common Lisp, lists are used to
denote all syntactic structures as lists of symbols and expressions. The
\rnrs report gives the following notation for let, the construct for
creating local bindings

\begin{lstlisting}
  (let ((x (+ 1 2))
        (y (car '(1 2)))
        (z (+ x y)))
     ...)
\end{lstlisting}

In contrast, Clojure uses the following structure for let bindings

\begin{lstlisting}
  (let [x (+ 1 2)
        y (first [1 2])
        z (+ x y)]
    ...)
\end{lstlisting}

with the commas being whitespace and the [] pairing serving to clearly
textually delineate the bindings as a syntactic structure from the normal
function or macro meaning of ().

Vectors represent an immutable trie mapping indexes to raw arrays. Writing a
vector computes a new vector with the trie path to the mutated leaf array,
with time $O(log_2(n))$. Reading from a vector is similarly
$O(log_2(n))$. That is to say, vectors are an appropriate random access
datastructure while lists are an appropriate sequential scan datastructure.

\section{Tuples}


A sequence of items delimited by \#[ ... ]

As with Vectors, Tuples textually represent a datastructure not the operation
of program execution. Where vectors are an appropriate datastructure for
storing and randomly accessing large ammounts of data, they aren't such an
efficient representation for collections smaller a couple times the backing
array size. This means that using a Vector to store structures such as pairs
and tripples is more expensive than it needs to be. Tuples exist to provide a
more efficient representation for such structures.

\section{Maps}


A sequence of Tuples delimited by $\{ ... \}$

Maps represent an associative mapping between arbitrary values.

\begin{lstlisting}
  {#[:name
      {#[:first  "Reid"],
       #[:middle "Douglas"],
       #[:family "McKenzie"],
       #[:alias  "arrdem"],
       #[:given  "Reid Douglas McKenzie"],
       #[:full   "Reid Douglas 'arrdem' McKenzie"]}}
\end{lstlisting}

\chapter{The Runtime}


\chapter{The Type System}


\chapter{The Standard Library}


\end{document}
