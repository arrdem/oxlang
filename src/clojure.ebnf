file  := < junk * > ( sexpr < junk * > ) *

sexpr := "(" body ")"

body := < junk * > (expr < junk * > ) *

junk := ( whitespace | comment )

whitespace := #"\s"

comment := #";[^\n\r\f]*[\n\f]\r?"

expr := < ignored > (* FIXME: empty nodes *)
      / metaExpr
      / derefExpr
      / quoteExpr
      / rawExpr

metaExpr := meta < junk + > rawExpr

derefExpr := "@" < junk * > rawExpr

quoteExpr := "'" < junk * > rawExpr

rawExpr := sexpr
         / number
         / keyword
         / token
         / string
         / vector
         / map
         / character
         / dispatch
         / expr
         / symbol

number := floatNum
        | ratioNum
        | basedNum
        | bigNum
        | intNum

floatNum := #"[+-]?[0-9]+\.[0-9]+"

basedNum := intNum "r" intNum

bigNum := #"[+-]?[1-9][0-9]*M"

ratioNum := intNum "/" intNum

intNum := #"[+-]?[1-9][0-9]*"

meta := "^" ( symbol
            | keyword
            | map )

symbol := ( word ( "/" word ) ? ) | "/"

keyword := ":" ":" ? word ( "/" word ) ?

word := #"[^/\s\(\)\d\^\@\'][^/\s\(\)\[\]\{\}\^\@\']*"

token := nilExpr
       | nanExpr
       | infExpr
       | boolExpr

nilExpr := "nil"

nanExpr := ("+" | "-")? "NaN"  (* Extension to the Clojure reference grammar *)

infExpr := ("+" | "-")? "Infinity" (* Extension to the Clojure reference grammar *)

boolExpr := "true" | "false"

string := "\"" ( unicodeChar
               | escape
               | char ) *
          "\""

escape := "\\" ( quoteEscape
               | tabEscape
               | retEscape
               | newlineEscape
               | slashEscape
               | breakEscape
               | feedEscape )

quoteEscape := "\""

tabEscape := "t"

retEscape := "r"

newlineEscape := "n"

slashEscape := "\\"

breakEscape := "b"

feedEscape := "f"

char := #"[^\"]"

vector := "[" body "]"

map := "{" body "}"

character := "\\" (namedChar | unicodeChar | char)

namedChar := returnChar
           | tabChar
           | newlineChar
           | spaceChar
           | backspaceChar

returnChar := "return"

tabChar := "tab"

newlineChar := "newline"

spaceChar := "space"

backspaceChar := "backspace"

unicodeChar := uChar | oChar

uChar := "u" #"[0-9A-F]{4}"

oChar := "o" #"[0-8]{1,8}"

ignored := "#_" < junk * > expr

dispatch := "#" ( set
                | function
                | pattern
                | recordTypeOrClass
                | record
                | readerExpr )

set := "{" body "}"

function := "(" body ")"

pattern := string

recordTypeOrClass := symbol vector

record := symbol map

readerExpr := symbol < whitespace > vector
