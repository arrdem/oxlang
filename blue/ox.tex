%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Programming/Coding Assignment
% LaTeX Template
%
% This template has been downloaded from:
% http://www.latextemplates.com
%
% Original author:
% Ted Pavlic (http://www.tedpavlic.com)
%
% Note:
% The \lipsum[#] commands throughout this template generate dummy text
% to fill the template out. These commands should all be removed when
% writing assignment content.
%
% This template uses a Perl script as an example snippet of code, most other
% languages are also usable. Configure them in the "CODE INCLUSION
% CONFIGURATION" subsection.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%       PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{report}

\usepackage[T1]{fontenc}
\usepackage[usenames,dvipsnames]{color}
\usepackage[utf8]{inputenc}
\usepackage{courier}
\usepackage{extramarks}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{lastpage}
\usepackage{lipsum}
\usepackage{listings}
\usepackage{textcomp}

% Margins
\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1} % Line spacing

% Set up the header and footer
\pagestyle{fancy}
\lhead{} % Top left header
\chead{} % Top center head
\rhead{} % Top right header
\lfoot{} % Bottom left footer
\cfoot{} % Bottom center footer
\rfoot{Page\ \thepage\ of\ \protect\pageref{LastPage}} % Bottom right footer
\renewcommand\headrulewidth{0.4pt} % Size of the header rule
\renewcommand\footrulewidth{0.4pt} % Size of the footer rule

\setlength\parindent{0pt} % Removes all indentation from paragraphs

%----------------------------------------------------------------------------------------
%       CODE INCLUSION CONFIGURATION
%----------------------------------------------------------------------------------------

\definecolor{MyDarkGreen}{rgb}{0.0,0.4,0.0} % This is the color used for comments
\lstloadlanguages{Perl} % Load Perl syntax for listings, for a list of other languages supported see: ftp://ftp.tex.ac.uk/tex-archive/macros/latex/contrib/listings/listings.pdf
\lstset{language=Perl, % Use Perl in this example
  frame=single, % Single frame around code
  basicstyle=\small\ttfamily, % Use small true type font
  keywordstyle=[1]\color{Blue}\bf, % Perl functions bold and blue
  keywordstyle=[2]\color{Purple}, % Perl function arguments purple
  keywordstyle=[3]\color{Blue}\underbar, % Custom functions underlined and blue
  identifierstyle=, % Nothing special about identifiers
  commentstyle=\usefont{T1}{pcr}{m}{sl}\color{MyDarkGreen}\small, % Comments small dark green courier font
  stringstyle=\color{Purple}, % Strings are purple
  showstringspaces=false, % Don't put marks in string spaces
  tabsize=5, % 5 spaces per tab
  %
  % Put standard Perl functions not included in the default language here
  morekeywords={rand},
  %
  % Put Perl function parameters here
  morekeywords=[2]{on, off, interp},
  %
  % Put user defined functions here
  morekeywords=[3]{test},
  %
  morecomment=[l][\color{Blue}]{...}, % Line continuation (...) like blue comment
  numbers=left, % Line numbers on left
  firstnumber=1, % Line numbers start with line 1
  numberstyle=\tiny\color{Blue}, % Line numbers are blue and small
  stepnumber=5 % Line numbers go in steps of 5
}

%----------------------------------------------------------------------------------------
%       NAME AND CLASS SUBSECTION
%----------------------------------------------------------------------------------------

\newcommand{\Title}{Ox, the Language} % Assignment title
\newcommand{\AuthorName}{Reid 'arrdem' McKenzie <me@arrdem.com>} % Your name

%----------------------------------------------------------------------------------------
%       TITLE PAGE
%----------------------------------------------------------------------------------------

\title{
  \vspace{2in}
  \textmd{\textbf{\Title}}\\
  \vspace{0.1in}\large{\textit{$0^{th}$ ed. [Draft]}}
  \vspace{3in}
}

\author{\textbf{\AuthorName}}
\date{} % Insert date here if you want it to appear below your name

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle

%----------------------------------------------------------------------------------------
%       TABLE OF CONTENTS
%----------------------------------------------------------------------------------------

%\setcounter{tocdepth}{1} % Uncomment this line if you don't want subsubsections listed in the ToC

\newpage
\tableofcontents
\newpage

\chapter{Motivation}

This chapter is a candidate for later deletion but for now I find it expedient
to keep it around.

Ox is born first and foremost of Rich Hickey's language Clojure. After spending
a summer hacking on Oxcart, an optimizing Clojure compiler intended to be my
undergraduate thesis material, I came to the conclusion that the compiler I
produced targeted a sufficiently restricted subset of Clojure that it was a
different beast altogether and that since I had already jumped the shark and
built my own Lisp I may as well go whole hog and deal with some bugbears of mine
in Clojure while I was at it.

The result is Ox. Ox is a Lisp at least in name, which seeks to steal the best
of Clojure's imperative but mostly side effect free word and Haskell's types and
category theory, then mix it together with a lispy notation. The hope is that in
so doing, the rewards of static typing and static reasoning (more advanced
optimization and proofs about properties of programs) can be made achievable in
a near Clojure language on the JVM platform while learning from Clojure's
evolutionary history and leaving the door open to other platforms in the form of
a Shen like portable testable language specification.

The goal of this document is to present, in a structured, printable, coherent
form the design philosophy of the Ox language, the philosophy under which it
will be developed, the language itself and some thoughts with respect to its
use.

\chapter{The Reader and Notation}

Ox, being a Lisp family language, uses an expression based syntax which seeks to
share as much notation as possible between logical evaluated code and data so
that the $eval$ relation from data to code is as transparent as possible. An
expression in Ox is one of the following



\subsection{Whitespace}

The \verb|;| character is the comment prefix. All characters between a
\verb|;| and the end of line are ignored and discarded.

The space, tab, newline, page break and linefeed characters are all white
space and ignored in between individual forms. That is to say a single list as
subsequently defined may span arbitrarily much whitespace and arbitrarily many
lines. That is not to say that individual terms such as symbols can span lines
and whitespace unless they are specifically noted to do so or contain subforms
between which whitespace is always valid.

\subsection{Lists}

a sequence of terms delimited by ( ... )

Lists are used as the basic syntactic element. Logically, the first expression
in a list will be evaluated, then the second expression, and soforth until the
list itself is evaluated by invoking the result of the first expression
(assumed to be a function) with the results of the subexpressions. This
implicit stateful execution model (which we will relax in time) means that Ox
code can be read and understood as the sequent of all the sequential list
forms. List \& symbol expressions occurring in data elements such as maps and
vectors will be realized in expression order unless the expression or any
parent expression is quoted.

Textual Lists represent one of the traditional list structures. The
abstraction of an immutable singly linked list is guranteed. Chunking, lazy
realization and other optimizations are allowed.

\subsection{Symbols}

A sequence of characters forming a name

Symbols are how things are named in Ox. A symbol consists logically of a tuple
\verb|<namespace, name>| written textually as \verb|namespace/name|. This is
said to be a qualified symbol, in that the namespace uniquely identifies the
packaging context of a given symbol and then uniquely names the symbol within
that context.

FIXME: name requirements

FIXME: namespace as a sequence of . joined names

\subsection{Keywords}

A \verb|":"| prefixed Symbol

Keywords are symbolic values suitable for use as in an enumeration. Keywords
share all the notation and restrictions of a Symbol, except that Keywords have
the prefix pattern \verb|"::?"| where Symbols do not tolerate the leading
\verb|":"| character. Note that this makes parsing a Keyword vs parsing a
Symbol unambiguous.

\subsection{Strings}

A block of arbitrary text contained within double or tripple quotes

TODO: What do we want/need tripple quoted strings for?

Double quoted strings are for character strings as program data and constants.

Tripple quoted strings are for documentation, are expected to be fully
indented to the indentation level of the containing block and contains text
formatted in accordance to the Common Markdown specification.

\begin{lstlisting}
  (def foo
  """
  # The Foo Function

  This is some documentation that totally starts with a Markdown header and
  may contain Markdown code blocks, underlines, italics and soforth.
  """

  (fn [x] ...))
\end{lstlisting}

Being data, strings evaluate to themselves. Strings contain no subterms.

\subsection{Vectors}

A sequence of terms delimited by [ ... ]

Where lists are notation for code and function invocation, vectors are
notation for ordered binding terms.

In a traditional Lisp (say an $R^nRS$) or Common Lisp, lists are used to
denote all syntactic structures as lists of symbols and expressions. The
$R^nRS$ report gives the following notation for let, the construct for
creating local bindings

\begin{lstlisting}
  (let ((x (+ 1 2))
  (y (car '(1 2)))
  (z (+ x y)))
  ...)
\end{lstlisting}

In contrast, Clojure uses the following structure for let bindings

\begin{lstlisting}
  (let [x (+ 1 2),
    y (first [1 2]),
    z (+ x y)]
  ...)
\end{lstlisting}

with the commas being whitespace and the [] pairing serving to clearly
textually delineate the bindings as a syntactic structure from the normal
function or macro meaning of ().

Vectors represent an immutable trie mapping indexes to raw arrays. Writing a
vector computes a new vector with the trie path to the mutated leaf array,
with time $O(log_2(n))$. Reading from a vector is similarly
$O(log_2(n))$. That is to say, vectors are an appropriate random access
datastructure while lists are an appropriate sequential scan datastructure.

\subsection{Tuples}

A sequence of items delimited by \#[ ... ] or 〈 ... 〉

As with Vectors, Tuples textually represent a datastructure not the operation
of program execution. Where vectors are an appropriate datastructure for
storing and randomly accessing large ammounts of data, they aren't such an
efficient representation for collections smaller a couple times the backing
array size. This means that using a Vector to store structures such as pairs
and tripples is more expensive than it needs to be. Tuples exist to provide a
more efficient representation for such structures.

\subsection{Maps}

A sequence of Tuples delimited by $\{ ... \}$

Maps represent an associative mapping between arbitrary values.

\begin{lstlisting}
  {#[:name
      {#[:first  "Reid"],
        #[:middle "Douglas"],
        #[:family "McKenzie"],
        #[:alias  "arrdem"],
        #[:given  "Reid Douglas McKenzie"],
        #[:full   "Reid Douglas 'arrdem' McKenzie"]}}
\end{lstlisting}

\chapter{The Runtime}

\chapter{The Type System}

\chapter{The Standard Library}

\end{document}
