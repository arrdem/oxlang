# ç‰› - Blue proposal

This proposal assumes the parser grammar and read-eval model of the [Straw man](/straw/) proposal without modification.
The goal of this proposal is to revise the Straw man, and moderate the [Green](/green/) proposal.
Specifically, this proposal seeks to recover the implicit evaluation state at least within a single namespace.
This hopefully will allow Blue to keep the feel of Clojure with only the `(ns)` form for a file header while achieving the desired immutable env semantics.

This proposal steals from [Dunaj](http://dunaj.org) in that no special forms are defined.
Instead, only the standard library and the namespace in which it resides are defined as the logical interface to the language.
Special forms may exist, and may be generated by macros in the standard library, but are not be exposed to the user and are not guaranteed at the API level.
This particular tactic is perhaps worth unquestioned adoption as it sidesteps the otherwise sticky issue of choosing special forms.

## Named arguments
In some contexts, such as database drivers, many operations may require a "configuration" value as the first parameter.
Repetition of this value is an undue burden on the programmer for in the pure configuration case the value is constant.
However existing macro techniques require wrapping of every single function having these semantics in order to express the partial application with respect to a configuration.
Other solutions such as binding dynamic vars and applying with fewer arguments are unsatisfactory because they involve mutable state.

A proposed resolution to this problem is the abuse of multiple-arity functions and the introduction of the `with` macro.
In a function definition, a user may namespace qualify an argument.
The `with` macro takes a binding structure as `let` does, except that it binds namespace qualified parameter names.
So for instance

```Clojure
(defn sdb/flush! [sdb/*db*]
  ...)

(defn sdb/clear! [sdb/*db*]
  ...)

(with [sdb/*db* (get-database)]
  (flush!)
  (clear!))
```

would be possible.

This is entirely macro sugar on the part of the `with` form.
The `with` form macroexpands and then rewrites all call sites within its body, matching elided named arguments to `with` bound named values.

## Mutable values
One class of problem which Clojure and Haskell both struggle with is the problem of updating two logical values in an interleaved fashion.
Haskell solves this problem to some extent with monad combinators, making it possible to change monad contexts and achieve different effects.
In vanilla Clojure, this is possible by abusing the fact that let is an in-order binding operation.
However code written by rebinding names in a let block is almost unreadable.
Or something along these lines.

Terms matching "<sym> <- <form>" become let bindings.
Terms matching "<sym>" are left as statements.
The entire thing rewrites to nested lets and statements.

```Clojure
;; before
(let [x (+ 1 (f))
      y (* x 3)
      x (/ y 2)]
	  ...)

;; after
(mut!
  x <- (+ 1 (f))
  y <- (* x 3)
  x <- (/ y 2)
  ...)
```
