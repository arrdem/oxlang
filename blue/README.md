-*- mode: markdown; mode: poly-markdown; -*-
# 牛, Ox - Blue proposal

The goal of this proposal is to revise the Straw man, and moderate the [Green](/green/) proposal.
There is also a fair bit of influence in this proposal from Haskell and [Dunaj](http://dunaj.org).

This proposal has a few goals:

- Standard library as the API, not special forms
- Named argument support
- Lack of varargs (and apply as a result)
- Type inference
- Compiler as a server model

## Standard library
This proposal steals from Dunaj in that no special forms are defined.
Instead, only the standard library and the namespace in which it resides are defined as the logical interface to the language.
Special forms may exist, and may be generated by macros in the standard library, but are not be exposed to the user and are not guaranteed at the API level.
This particular tactic is perhaps worth unquestioned adoption as it sidesteps the otherwise sticky issue of choosing special forms.
This also lends itself to a nice hosted implementation with a large logical "base" in that the base environment simply provides all of the standard library with minimal bootstrapping rather than attempting to be even mostly self-hosting.

## Named arguments
In some contexts, such as database drivers, many operations may require a "configuration" value as the first parameter.
Repetition of this value is an undue burden on the programmer for in the pure configuration case the value is constant.
However existing macro techniques require wrapping of every single function having these semantics in order to express the partial application with respect to a configuration.
Other solutions such as binding dynamic vars and applying with fewer arguments are unsatisfactory because they involve mutable state.

A proposed resolution to this problem is the abuse of multiple-arity functions and the introduction of the `with-args` macro.
In a function definition, a user may namespace qualify an argument.
The `with-args` macro takes a binding structure as `let` does, except that it binds namespace qualified parameter names.
So for instance

```clojure
(defn sdb/flush!
  "Flushes the database to the backing file."
  [sdb/*db*]
  ...)

(defn sdb/clear!
  "Empties the database entirely."
  [sdb/*db*]
  ...)

(with-args [sdb/*db* (get-database)]
  (flush!)
  (clear!))
```

Scala can already do this with implicits, Haskell can also do this see ftp://madison.deas.harvard.edu/techreports/tr-15-04.pdf.
@brandonbloom claims that this requires a language extension not a simple rewrite macro due to issues with delayed evaluation.
I think you could do this entirely with call site rewriting.
The argument to this effect is that the `with-args` macro simply changes the semantics of invoke within its body to insert implicit named arguments as appropriate.
Fully rewritten, the above example becomes:

```clojure
(let [gen_*db*_50 (get-database)]
  (flush! gen_*db*_50)
  (clear! gen_*db*_50))
```

which has precisely the same operational and denotational semantics as if one were to write the same code without implicit arguments.
It's worthwhile questioning whether this system can support multiple optional arguments, and how optional arguments interact with [Varargs](#varargs).
I think the answer is that changes to the way varargs behave are required in order to support this pattern without types.
Consider the example

```clojure
;; Continuing from the first example above
(defn sdb/assoc!
  "Writes a key into the kv store."
  [sdb/*db* key val]
  ...)

(defn sdb/get!
  "Reads a key from the kv store, potentially mutating caches."
  ([sdb/*db* key]
   ...)
  ([sdb/*db* key not-found]
   ...))

(defn sdb/get-all!
  "Logically the map of get! over a number of keys."
  [sdb/*db* & keys]
  ...)

(with-args [sdb/*db* (get-database)]
  (let [other-db (get-other-database)
        res      (sdb/get-all! other-db :a :b :c :d)]
    (doseq [r res]
      (sdb/assoc! r nil))))

```

Without type information, the `(sdb/get-all! ...)` form is ambiguous.
A simple macro has no way to know that `other-db` is a legitimate configuration value, and that consequently the `(sdb/get-all! ...)` term is "complete" and does not require completion with the logical value of `sdb/*db*`.

One solution to this problem is to mirror what the Haskell folks do in the above paper and use type information to drive this argument completion.
As one of the likely results of the Ox project will be a type system, this is something I'm totally open to.

Another _workaround_ that doesn't require type information is that we can change the way varargs are handled so that the "more inline args" case isn't actually possible.
Again coming from the types and Haskell side of things this is an option I'm open to.

## Varargs

The two common cases for using varargs in a function are either that as in `clojure.core/+` a `foldr` is generated over the argument tail.
The other is that the arguments tail is compiled into a map and used as a mechanism for passing keyword arguments.
While there is a long tradition of keyword arguments, and the topic of keyword arguments vs explicit map arguments remains a contentious one in the Clojure community [1](https://groups.google.com/d/msg/clojure/yzLCZh-GiQ8/etKrIdgJz-sJ), [2](http://dev.clojure.org/display/community/Library+Coding+Standards), [3](http://yellerapp.com/posts/2015-03-22-the-trouble-with-kwargs.html), I would argue that the community coding standard is in most cases shifting towards an explicit map argument because explicit map args compose better and can be partially applied easily.

In the case of kwargs, the problem is that as currently implemented such arguments must go through a map, and either map merging or implicit nil is used to implement default values.
Using kwargs notation is just that, notation and comes in the best case at the same performance of using a map and the cost of an API in which settings values don't compose nicely.
Consequently I discard the case of kwargs as a justification for supporting varargs.

The other identified common case of varargs is when as in `clojure.core/+`, `clojure.core/-`, `clojure.core/*` and `clojure.core//` a function has a base case and an implicit `foldr` over all its arguments.
Honestly I'm not sure about this.
On the one hand, from a notation standpoint, prefix is awkward compared to infix especially for binary operators as with the math ops here.
Traditionally at least in the western mathematics tradition infix is used for writing binary operators.
In prefix as well, unless explicitly arity overloaded with parentheticals Ex `+ + 1 2 3` vs `(+ 1 2 3)`.
As a result, the Σ notation exits for operating on a group (logical sequence described by a single production) of terms.
Thus we have `(def Σ (partial foldr + 0))`, for `+` being a binary operator and `+` is a function of arity two.

This is notationally breaking since it's traditional for Lisps to support arity overloading and if `+` is strictly a function of two arguments that doesn't quite work.
In Clojure, macros are functions from expressions to expressions tagged with `{[:macro true]}` metadata to indicate that they should be invoked at macroexpand time.



## Mutable values
One class of problem which Clojure and Haskell both struggle with is the problem of updating two logical values in an interleaved fashion.
Haskell solves this problem to some extent with monad combinators, making it possible to change monad contexts and achieve different effects.
In vanilla Clojure, this is possible by abusing the fact that let is an in-order binding operation.
However code written by rebinding names in a let block is almost unreadable.
Or something along these lines.

Terms matching "<sym> <- <form>" become let bindings.
Terms matching "<sym>" are left as statements.
The entire thing rewrites to nested lets and statements.

```clojure
;; before
(let [x (+ 1 (f))
      _ (println x)
      y (* x 3)
      _ (println y)
      x (/ y 2)]
  ...)

;; after
(mut!
  x <- (+ 1 (f))
  (print x)
  y <- (* x 3)
  (print y)
  x <- (/ y 2)
  ...)
```
