# ç‰› - Blue proposal

This proposal assumes the parser grammar and read-eval model of the [Straw man](/straw/) proposal without modification.
The goal of this proposal is to revise the Straw man, and moderate the [Green](/green/) proposal.
Specifically, this proposal seeks to recover the implicit evaluation state at least within a single namespace.
This hopefully will allow Blue to keep the feel of Clojure with only the `(ns)` form for a file header while achieving the desired immutable env semantics.

This proposal steals from [Dunaj](http://dunaj.org) in that no special forms are defined.
Instead, only the standard library and the namespace in which it resides are defined as the logical interface to the language.
Special forms may exist, and may be generated by macros in the standard library, but need not be exposed to the user.

## *empty-env*

As in the Green proposal, this value represents an maximally empty environment, and is the initial environment of the evaluator when compiling any module.
Despite its name, the empty environment isn't actually empty, it provides the mapping of the `ns` form, which is required for the `ns` form to be a first class form rather than simply being a module header statement block ala Java or Haskell.

## ns

```Clojure
(ns namespace
    docstring?
    attr-map?
    require-spec*)
```

Where the `require-spec` term refers to the `(:require [<ns> (:as <alias>)? (:refer [<sym>*])])` language used in Clojure.
The `require-spec` term may be extended to some form of `module-spec` term, which would allow for language and dependency options beyond simple requirements.
Note that unlike Clojure, `ns` will _not_ implicitly require the "standard library" namespace.
This choice is made so that as in C, alternative implementations, versions or packagings of the standard library become usable.
Users are expected to instead include the form `(:require [ox.core :refer :all])`.
It is an error to have two `ns` forms in a single file.

## ox.core/if

```Clojure
(if <expr> <lhs> <rhs>)
```

Two armed if.
Both arms must be provided.
Evaluates `lhs` if the condition is true, and `rhs` if the condition is false.
It is an error for `if` to be used in a single armed case.

## ox.core/when

`clojure.core/when`

## ox.core/not

`clojure.core/not`

## ox.core/when-not

`clojure.core/when-not`

## ox.core/let

One after the other let.
Supports destructuring.

## ox.core/do

```Clojure
(do form+)
```

Statement of several forms, returning the result of the tail form.

## ox.core/fn

```Clojure
(fn name? [arg*]
    form+)
```

Returns a function.
Functions are of single arity, and while they may contain multiple statements return the value of the tail expression.
Supports argument destructuring.

## ox.core/load

```Clojure
(load <opts-map> <path-string>)
```

Reads and loads the file indicated by the path.
The file is evaluated not from the empty environment, but from the current environment and for effects on the current environment.
If the pair `[:current-env true]` is present, then the file is loaded in the current env, and this form has the effect of form-wise inclusion.
If the pair `[:current-env false]` is present, or if the `:current-env` key is missing, then the referenced file is simply compiled from the empty environment.
This compilation may be lazy and may be cached by the implementation.
If the pair `[:reload true]` is present, then compilation must be re-performed.

## ox.core/def

```Clojure
(def sym attr-map? docstring? val)
```

Binds a name in the current namespace to a value.
Defs are single, and defs are static, defs are global.

## ox.core/defn

Macro wrapping ox.core/def and ox.core/fn.

## ox.core/deftype

Macro defining a type which may or may not be backed by a host type.

## ox.core/defprotocol

Macro defining a logical interface, which may be extended over types. May or may not be backed by a host type.

## ox.core/extend-procotol

Macro for extending a protocol over a type.

## ox.core/eval

```Clojure
(eval env form)
```

Returns a pair `[env, result]` where the env is the evaluation environment after the execution of the `form`, and `result` is the value collection values returned by `result`.

## ox.core/quote
